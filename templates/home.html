<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Nonograph - Anonymous Publishing Service</title>
        <style>
            :root {
                --button-bg: #333;
                --button-hover: #000;
                --button-active: #111;
                --button-text: #ffffff;
                --menu-bg: #ffffff;
                --menu-text: #333;
                --menu-hover: #f5f5f5;
                --menu-selected: #e8e8e8;
                --menu-border: #ddd;
                --menu-shadow: rgba(0, 0, 0, 0.15);
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
            body {
                font-family:
                    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                    sans-serif;
                padding: 40px;
                line-height: 1.6;
                background: #ffffff;
                color: #333;
                transition:
                    background-color 0.3s ease,
                    color 0.3s ease;
            }
            .container {
                position: relative;
                max-width: 1000px;
                margin: 0 auto;
            }
            .writingarea {
                width: 700px;
                margin: 0 auto;
                position: relative;
            }
            .content {
                width: 100%;
            }
            .sidebar {
                position: absolute;
                left: 50%;
                margin-left: 390px;
                top: 0px;
                width: 200px;
                text-align: left;
            }
            input[type="text"],
            textarea {
                width: 100%;
                padding: 0;
                border: none;
                font-size: 18px;
                background: transparent;
                font-family: Georgia, "Times New Roman", Times, serif;
                box-shadow: none;
                -webkit-box-shadow: none;
                -moz-box-shadow: none;
                -webkit-appearance: none;
                -moz-appearance: none;
                color: inherit;
            }
            input[type="text"]:focus,
            textarea:focus {
                outline: none;
            }
            input[type="text"]::placeholder,
            textarea::placeholder {
                color: currentColor;
                opacity: 0.4;
            }
            input[type="text"] {
                font-size: 30px;
                font-weight: 600;
                margin-bottom: 0;
                height: 60px;
            }
            input[type="text"].author-input {
                font-size: 16px;
                font-weight: 400;
                height: 24px;
                margin-bottom: 16px;
                opacity: 0.7;
            }
            textarea {
                min-height: 100px;
                font-size: 18px;
                resize: none;
                line-height: 1.6;
                -webkit-overflow-scrolling: touch;
                padding-bottom: 300px;
            }
            button {
                background: var(--button-bg);
                color: var(--button-text);
                padding: 16px 32px;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                margin-bottom: 16px;
                margin-top: 0;
                min-height: 44px;
                transition: background-color 0.2s ease;
                -webkit-tap-highlight-color: transparent;
                position: relative;
                overflow: hidden;
            }
            button::before {
                content: "";
                position: absolute;
                top: 0;
                left: -100%;
                width: 100%;
                height: 100%;
                background: linear-gradient(
                    90deg,
                    transparent,
                    rgba(255, 255, 255, 0.2),
                    transparent
                );
                transition: left 0.5s ease;
            }
            button:hover::before {
                left: 100%;
            }
            button:hover {
                background: var(--button-hover);
            }
            button:active {
                background: var(--button-active);
                transform: translateY(1px);
            }
            button:disabled {
                background: #999;
                cursor: not-allowed;
                transform: none;
            }
            button:disabled::before {
                display: none;
            }
            .char-count {
                font-size: 11px;
                color: inherit;
                opacity: 0.5;
                margin-bottom: 16px;
            }
            .char-count.over-limit {
                color: #e74c3c;
                opacity: 1;
            }
            label {
                display: block;
                font-size: 12px;
                color: inherit;
                opacity: 0.6;
                margin-bottom: 4px;
            }
            .links {
                font-size: 12px;
                display: flex;
                flex-direction: column;
                gap: 4px;
            }
            .links a {
                color: inherit;
                opacity: 0.6;
                text-decoration: none;
            }
            .links a:hover {
                opacity: 1;
                text-decoration: underline;
            }

            /* Theme Items in Slash Menu */
            .menu-item.theme-item .theme-preview {
                width: 24px;
                height: 20px;
                border-radius: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 13px;
                font-weight: 600;
                font-family: Georgia, serif;
                margin-left: auto;
            }

            /* Editor Menu Styles */
            .editor-menu {
                position: absolute;
                background: var(--menu-bg);
                border: 1px solid var(--menu-border);
                border-radius: 4px;
                box-shadow: 0 4px 20px var(--menu-shadow);
                padding: 6px;
                z-index: 1000;
                display: none;
                max-height: 300px;
                overflow-y: auto;
                min-width: 200px;
            }
            .editor-menu.active {
                display: block;
            }
            .editor-menu::-webkit-scrollbar {
                width: 8px;
            }
            .editor-menu::-webkit-scrollbar-track {
                background: var(--menu-hover);
                border-radius: 4px;
            }
            .editor-menu::-webkit-scrollbar-thumb {
                background: #ccc;
                border-radius: 4px;
            }
            .editor-menu::-webkit-scrollbar-thumb:hover {
                background: #999;
            }
            .menu-item {
                padding: 6px 12px;
                cursor: pointer;
                font-size: 14px;
                font-family:
                    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                    sans-serif;
                color: var(--menu-text);
                border-radius: 4px;
                display: flex;
                align-items: center;
                gap: 8px;
                white-space: nowrap;
                transition: all 0.15s ease;
            }
            .menu-item:hover {
                background: var(--menu-hover);
            }
            .menu-item.selected {
                background: var(--menu-selected);
            }
            .menu-label {
                font-weight: 500;
            }
            .menu-shortcut {
                font-size: 12px;
                color: #999;
                margin-left: auto;
            }

            /* Mobile Styles */
            @media (max-width: 1040px) {
                .container {
                }
                .writingarea {
                    width: 100%;
                    max-width: 700px;
                }
                .sidebar {
                    position: static;
                    left: auto;
                    margin-left: 0;
                    margin-top: 32px;
                    width: 100%;
                    text-align: left;
                    display: flex;
                    flex-direction: column;
                    align-items: flex-start;
                    gap: 16px;
                }
                .sidebar button {
                    width: 100%;
                    max-width: 200px;
                }
            }

            @media (max-width: 768px) {
                body {
                    padding: 16px;
                }
                .container {
                    padding: 0;
                }
                .writingarea {
                    width: 100%;
                }
                input[type="text"] {
                    font-size: 24px;
                    height: 50px;
                    line-height: 1.3;
                }
                input[type="text"].author-input {
                    font-size: 16px;
                    height: 32px;
                }
                textarea {
                    font-size: 16px;
                    line-height: 1.5;
                    min-height: 200px;
                    padding-bottom: 200px;
                }
                .sidebar {
                    margin-top: 24px;
                    gap: 12px;
                }
                .sidebar button {
                    padding: 14px 28px;
                    font-size: 16px;
                    min-height: 48px;
                }
                .char-count {
                    font-size: 12px;
                }
                .links {
                    font-size: 14px;
                    flex-direction: row;
                    flex-wrap: wrap;
                    gap: 16px;
                }
                .links a {
                    padding: 8px 0;
                    min-height: 44px;
                    display: flex;
                    align-items: center;
                }
            }

            @media (max-width: 480px) {
                body {
                    padding: 12px;
                }
                input[type="text"] {
                    font-size: 22px;
                    height: 48px;
                }
                input[type="text"].author-input {
                    font-size: 16px;
                    height: 32px;
                }
                textarea {
                    font-size: 16px;
                    min-height: 180px;
                    padding-bottom: 150px;
                }
                .sidebar button {
                    width: 100%;
                    max-width: none;
                    padding: 16px;
                    font-size: 16px;
                    min-height: 52px;
                }
                .sidebar {
                    margin-top: 20px;
                }
                .links {
                    width: 100%;
                    justify-content: space-between;
                }
                .links a {
                    flex: 1;
                    justify-content: center;
                    text-align: center;
                    min-height: 48px;
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="writingarea">
                <form
                    action="/create"
                    method="post"
                    id="publishForm"
                    class="content"
                >
                    <input
                        type="text"
                        name="title"
                        placeholder="Title"
                        maxlength="128"
                        title="Mind your opsec. Limited to 128 characters."
                        required
                    />
                    <input
                        type="text"
                        name="alias"
                        placeholder="Alias (optional)"
                        maxlength="32"
                        class="author-input"
                        title="Mind your opsec. Limited to 32 chracters."
                    />
                    <textarea
                        name="content"
                        placeholder="Write something with markdown or type / for formatting options..."
                        maxlength="128000"
                        title="Mind your opsec, be careful what you share."
                        required
                    ></textarea>
                    <input
                        type="hidden"
                        name="csrf_token"
                        value="{{csrf_token}}"
                    />
                    <input
                        type="hidden"
                        name="theme"
                        id="themeInput"
                        value="0"
                    />
                </form>
            </div>

            <div class="sidebar">
                <button type="submit" form="publishForm">Publish</button>
                <div class="char-count" id="charCount">0 / 128,000</div>
                <div class="links">
                    <a href="/markup" target="_blank">markup guide</a>
                    <a href="/legal" target="_blank">legal &amp; privacy</a>
                    <a href="https://github.com/du82/nonograph" target="_blank"
                        >source code</a
                    >
                </div>
            </div>
        </div>

        <div class="editor-menu" id="slashMenu"></div>

        <script>
            // DOM elements
            const el = {
                textarea: document.querySelector('textarea[name="content"]'),
                charCount: document.getElementById("charCount"),
                form: document.getElementById("publishForm"),
                slashMenu: document.getElementById("slashMenu"),
                themeInput: document.getElementById("themeInput"),
                body: document.body,
                root: document.documentElement,
            };

            // Constants
            const CHAR_LIMIT = 128000;
            const LINE_HEIGHT = 28.8;
            const MENU_WIDTH = 300;
            const MENU_HEIGHT = 50;
            const PADDING = 10;

            // Theme configuration with color helpers
            // Load themes from backend
            const themesJson = `{{themes_json}}`;
            // Decode HTML entities that may have been escaped
            const decodedJson = themesJson
                .replace(/&quot;/g, '"')
                .replace(/&amp;/g, "&")
                .replace(/&lt;/g, "<")
                .replace(/&gt;/g, ">");
            const themes = JSON.parse(decodedJson);

            // State
            let state = {
                currentTheme: 0,
                previewTheme: null,
                slashMenuActive: false,
                slashPosition: -1,
                selectedMenuIndex: 0,
                slashQuery: "",
                lastScrollPosition: 0,
            };

            // Menu items configuration
            const menuItems = [
                {
                    label: "Heading 1",
                    format: "# ",
                    shortcut: "Ctrl+Alt+1",
                    key: "1",
                    altKey: true,
                    blockLevel: true,
                },
                {
                    label: "Heading 2",
                    format: "## ",
                    shortcut: "Ctrl+Alt+2",
                    key: "2",
                    altKey: true,
                    blockLevel: true,
                },
                {
                    label: "Heading 3",
                    format: "### ",
                    shortcut: "Ctrl+Alt+3",
                    key: "3",
                    altKey: true,
                    blockLevel: true,
                },
                {
                    label: "Heading 4",
                    format: "#### ",
                    shortcut: "Ctrl+Alt+4",
                    key: "4",
                    altKey: true,
                    blockLevel: true,
                },
                {
                    label: "Bold",
                    format: "****",
                    cursorOffset: -2,
                    shortcut: "Ctrl+B",
                    key: "b",
                    inline: true,
                },
                {
                    label: "Italic",
                    format: "**",
                    cursorOffset: -1,
                    shortcut: "Ctrl+I",
                    key: "i",
                    inline: true,
                },
                {
                    label: "Underline",
                    format: "__",
                    cursorOffset: -1,
                    shortcut: "Ctrl+U",
                    key: "u",
                    inline: true,
                },
                {
                    label: "Strikethrough",
                    format: "~~",
                    cursorOffset: -1,
                    shortcut: "Ctrl+Shift+X",
                    key: "x",
                    shiftKey: true,
                    inline: true,
                },
                {
                    label: "Superscript",
                    format: "^^",
                    cursorOffset: -1,
                    shortcut: "Ctrl+Shift+P",
                    key: "p",
                    shiftKey: true,
                    inline: true,
                },
                {
                    label: "Highlight",
                    format: "====",
                    cursorOffset: -2,
                    shortcut: "Ctrl+H",
                    key: "h",
                    inline: true,
                },
                {
                    label: "Inline Code",
                    format: "``",
                    cursorOffset: -1,
                    shortcut: "Ctrl+E",
                    key: "e",
                    inline: true,
                },
                {
                    label: "Code Block",
                    format: "\n```\n\n```",
                    cursorOffset: -4,
                    shortcut: "Ctrl+Shift+C",
                    key: "c",
                    shiftKey: true,
                    blockLevel: true,
                },
                {
                    label: "Link",
                    format: "[](url)",
                    cursorOffset: -6,
                    shortcut: "Ctrl+K",
                    key: "k",
                    inline: true,
                },
                {
                    label: "Image",
                    format: "![](url)",
                    cursorOffset: -6,
                    shortcut: "Ctrl+Shift+I",
                    key: "i",
                    shiftKey: true,
                    inline: true,
                },
                {
                    label: "Video",
                    format: "![](url)",
                    cursorOffset: -6,
                    shortcut: "Ctrl+Shift+V",
                    key: "v",
                    shiftKey: true,
                    inline: true,
                },
                {
                    label: "Blockquote",
                    format: "> ",
                    shortcut: "Ctrl+Shift+9",
                    key: "9",
                    shiftKey: true,
                    blockLevel: true,
                },
                {
                    label: "Bullet List",
                    format: "- ",
                    shortcut: "Ctrl+Shift+8",
                    key: "8",
                    shiftKey: true,
                    blockLevel: true,
                },
                {
                    label: "Numbered List",
                    format: "1. ",
                    shortcut: "Ctrl+Shift+7",
                    key: "7",
                    shiftKey: true,
                    blockLevel: true,
                },
                {
                    label: "Table",
                    format: "| Column 1 | Column 2 |\n|----------|----------|\n| Cell 1   | Cell 2   |",
                    cursorOffset: -47,
                    shortcut: "Ctrl+T",
                    key: "t",
                    blockLevel: true,
                },
                {
                    label: "Footnote Reference",
                    format: "[^1]",
                    shortcut: "Ctrl+Shift+R",
                    key: "r",
                    shiftKey: true,
                    inline: true,
                },
                {
                    label: "Inline Footnote",
                    format: "^[]",
                    cursorOffset: -1,
                    shortcut: "Ctrl+Shift+F",
                    key: "f",
                    shiftKey: true,
                    inline: true,
                },
                {
                    label: "Hidden Text",
                    format: "##",
                    cursorOffset: -1,
                    inline: true,
                },
                {
                    label: "Comment",
                    format: "// ",
                    shortcut: "Ctrl+/",
                    blockLevel: true,
                },
                {
                    label: "Thin Line Divider",
                    format: "\n---\n",
                    shortcut: "Ctrl+Shift+D",
                    key: "d",
                    shiftKey: true,
                    blockLevel: true,
                },
                {
                    label: "Double Line Divider",
                    format: "\n===\n",
                    blockLevel: true,
                },
                {
                    label: "Single Asterisk Divider",
                    format: "\n-*-\n",
                    blockLevel: true,
                },
                {
                    label: "Three Stars Divider",
                    format: "\n***\n",
                    blockLevel: true,
                },
            ];

            // Utility functions
            const utils = {
                isAtLineStart: () => {
                    const checkPos = state.slashMenuActive
                        ? state.slashPosition
                        : el.textarea.selectionStart;
                    const textBeforeCheck = el.textarea.value.substring(
                        0,
                        checkPos,
                    );
                    return (
                        checkPos === 0 ||
                        textBeforeCheck.charAt(textBeforeCheck.length - 1) ===
                            "\n"
                    );
                },

                getContextualMenuItems: () => {
                    const atLineStart = utils.isAtLineStart();
                    let filteredItems = menuItems.filter(
                        (item) =>
                            (!item.blockLevel && !item.inline) ||
                            atLineStart ||
                            item.inline,
                    );

                    if (state.slashQuery.trim()) {
                        filteredItems = filteredItems.filter((item) =>
                            item.label
                                .toLowerCase()
                                .includes(state.slashQuery.toLowerCase()),
                        );
                    }

                    return filteredItems;
                },

                getFilteredThemes: () => {
                    if (!state.slashQuery.trim()) return themes;

                    const query = state.slashQuery.toLowerCase();
                    if ("theme".includes(query) || "themes".includes(query))
                        return themes;

                    return themes.filter((theme) =>
                        theme.name.toLowerCase().includes(query),
                    );
                },

                autoResize: (element) => {
                    element.style.height = "auto";
                    element.style.height = element.scrollHeight + "px";
                },

                updateCharCount: () => {
                    const count = el.textarea.value.length;
                    const button = document.querySelector(
                        'button[type="submit"]',
                    );
                    el.charCount.textContent = `${count.toLocaleString()} / ${CHAR_LIMIT.toLocaleString()}`;

                    if (count > CHAR_LIMIT) {
                        el.charCount.classList.add("over-limit");
                        button.disabled = true;
                    } else {
                        el.charCount.classList.remove("over-limit");
                        button.disabled = false;
                    }
                },

                getCursorPosition: () => {
                    const cursorPos = el.textarea.selectionStart;
                    const textUpToCursor = el.textarea.value.substring(
                        0,
                        cursorPos,
                    );
                    const lines = textUpToCursor.split("\n");
                    const currentLineText = lines[lines.length - 1];

                    const rect = el.textarea.getBoundingClientRect();
                    const styles = window.getComputedStyle(el.textarea);
                    const paddingLeft = parseFloat(styles.paddingLeft);

                    const measurer = document.createElement("span");
                    Object.assign(measurer.style, {
                        font: styles.font,
                        fontSize: styles.fontSize,
                        fontFamily: styles.fontFamily,
                        visibility: "hidden",
                        position: "absolute",
                        whiteSpace: "pre",
                    });
                    measurer.textContent = currentLineText;
                    document.body.appendChild(measurer);

                    const textWidth = measurer.getBoundingClientRect().width;
                    document.body.removeChild(measurer);

                    return {
                        x: rect.left + paddingLeft + textWidth,
                        y:
                            rect.top +
                            parseFloat(styles.paddingTop) +
                            (lines.length - 1) * LINE_HEIGHT,
                        rect,
                    };
                },

                setCSSVar: (name, value) =>
                    el.root.style.setProperty(`--${name}`, value),

                localStorage: {
                    get: (key, defaultValue = null) => {
                        try {
                            return localStorage.getItem(key) !== null
                                ? JSON.parse(localStorage.getItem(key))
                                : defaultValue;
                        } catch {
                            return defaultValue;
                        }
                    },
                    set: (key, value) => {
                        try {
                            localStorage.setItem(key, JSON.stringify(value));
                        } catch {
                            // Silently fail
                        }
                    },
                },
            };

            // Theme functions
            const theme = {
                apply: (index, isPreview = false) => {
                    const t = themes[index];
                    el.body.style.backgroundColor = t.bg;
                    el.body.style.color = t.text;

                    // Set CSS variables
                    Object.keys(t).forEach((key) => {
                        if (key !== "name") {
                            const cssVarName = key
                                .replace(/([A-Z])/g, "-$1")
                                .toLowerCase();
                            utils.setCSSVar(cssVarName, t[key]);
                        }
                    });

                    if (!isPreview) {
                        state.currentTheme = index;
                        state.previewTheme = null;
                        el.themeInput.value = index;
                        utils.localStorage.set("selectedTheme", index);
                    } else {
                        state.previewTheme = index;
                    }
                },

                restore: () => {
                    if (state.previewTheme !== null) {
                        theme.apply(state.currentTheme, false);
                        state.previewTheme = null;
                    }
                },
            };

            // Menu functions
            const menu = {
                show: () => {
                    state.slashMenuActive = true;
                    const contextualItems = utils.getContextualMenuItems();
                    const filteredThemes = utils.getFilteredThemes();
                    el.slashMenu.innerHTML = "";

                    // Add format items
                    contextualItems.forEach((item, index) => {
                        const div = document.createElement("div");
                        div.className = `menu-item${index === 0 ? " selected" : ""}`;
                        div.innerHTML = `
                            <span class="menu-label">${item.label}</span>
                            ${item.shortcut ? `<span class="menu-shortcut">${item.shortcut}</span>` : ""}
                        `;
                        div.dataset.type = "format";
                        div.dataset.index = index;
                        div.addEventListener("click", () => format.apply(item));
                        el.slashMenu.appendChild(div);
                    });

                    // Add theme items
                    filteredThemes.forEach((t) => {
                        const themeIndex = themes.indexOf(t);
                        const div = document.createElement("div");
                        div.className = "menu-item theme-item";
                        div.innerHTML = `
                            <span class="menu-label">${t.name}</span>
                            <div class="theme-preview" style="background-color: ${t.bg}; color: ${t.text}">T</div>
                        `;
                        div.dataset.type = "theme";
                        div.dataset.index = themeIndex;
                        div.addEventListener("click", () => {
                            menu.selectTheme(themeIndex);
                        });
                        el.slashMenu.appendChild(div);
                    });

                    // Position menu
                    const pos = utils.getCursorPosition();
                    let menuX = pos.x;
                    if (menuX + MENU_WIDTH > pos.rect.right - PADDING) {
                        menuX = pos.rect.right - MENU_WIDTH - PADDING;
                    }
                    if (menuX < pos.rect.left + PADDING) {
                        menuX = pos.rect.left + PADDING;
                    }

                    let menuY = pos.y + 35;
                    if (menuY + MENU_HEIGHT > pos.rect.bottom) {
                        menuY = Math.max(
                            pos.y - MENU_HEIGHT - 15,
                            pos.rect.top + PADDING,
                        );
                    }

                    el.slashMenu.style.left = `${menuX}px`;
                    el.slashMenu.style.top = `${menuY}px`;
                    el.slashMenu.classList.add("active");

                    // Reset selection and preview first theme if applicable
                    state.selectedMenuIndex = 0;
                    el.slashMenu.scrollTop = 0;

                    // Auto-preview first theme if it's at the top
                    const firstItem = el.slashMenu.querySelector(".menu-item");
                    if (firstItem && firstItem.dataset.type === "theme") {
                        theme.apply(parseInt(firstItem.dataset.index), true);
                    }
                },

                hide: () => {
                    el.slashMenu.classList.remove("active");
                    state.slashMenuActive = false;
                    state.slashPosition = -1;
                    state.slashQuery = "";
                    theme.restore();
                },

                selectTheme: (themeIndex) => {
                    // Remove the slash command from text
                    const cursorPos = el.textarea.selectionStart;
                    const text = el.textarea.value;
                    const beforeSlash = text.substring(0, state.slashPosition);
                    const afterCursor = text.substring(cursorPos);

                    el.textarea.value = beforeSlash + afterCursor;
                    const newCursorPos = state.slashPosition;
                    el.textarea.setSelectionRange(newCursorPos, newCursorPos);

                    // Apply theme and hide menu
                    theme.apply(themeIndex, false);
                    menu.hide();

                    // Update character count and resize
                    utils.updateCharCount();
                    utils.autoResize(el.textarea);
                    el.textarea.focus();
                },

                updateSelection: () => {
                    const items = el.slashMenu.querySelectorAll(".menu-item");
                    items.forEach((item, index) => {
                        item.classList.toggle(
                            "selected",
                            index === state.selectedMenuIndex,
                        );
                        if (index === state.selectedMenuIndex) {
                            item.scrollIntoView({
                                block: "nearest",
                                behavior: "smooth",
                            });

                            if (item.dataset.type === "theme") {
                                theme.apply(parseInt(item.dataset.index), true);
                            } else {
                                theme.restore();
                            }
                        }
                    });
                },
            };

            // Format functions
            const format = {
                apply: (item, selectedText = null) => {
                    const start = el.textarea.selectionStart;
                    const end = el.textarea.selectionEnd;
                    const text = el.textarea.value;

                    if (state.slashMenuActive) {
                        const before = text.substring(0, state.slashPosition);
                        const after = text.substring(start);
                        el.textarea.value = before + item.format + after;
                        const cursorPos =
                            state.slashPosition +
                            item.format.length +
                            (item.cursorOffset || 0);
                        el.textarea.setSelectionRange(cursorPos, cursorPos);
                        menu.hide();
                    } else {
                        selectedText =
                            selectedText || text.substring(start, end);
                        const hasSelection = start !== end;
                        let newText, cursorPos;

                        // Handle special formatting cases
                        const formatMap = {
                            Bold: {
                                wrapper: "**",
                                emptyWrapper: "****",
                                emptyOffset: 2,
                                offset: 4,
                            },
                            Italic: {
                                wrapper: "*",
                                emptyWrapper: "**",
                                emptyOffset: 1,
                                offset: 2,
                            },
                            Underline: {
                                wrapper: "_",
                                emptyWrapper: "__",
                                emptyOffset: 1,
                                offset: 2,
                            },
                            Strikethrough: {
                                wrapper: "~",
                                emptyWrapper: "~~",
                                emptyOffset: 1,
                                offset: 2,
                            },
                            Superscript: {
                                wrapper: "^",
                                emptyWrapper: "^^",
                                emptyOffset: 1,
                                offset: 2,
                            },
                            Highlight: {
                                wrapper: "==",
                                emptyWrapper: "====",
                                emptyOffset: 2,
                                offset: 4,
                            },
                            "Inline Code": {
                                wrapper: "`",
                                emptyWrapper: "``",
                                emptyOffset: 1,
                                offset: 2,
                            },
                            "Code Block": {
                                wrapper: "```\n",
                                emptyWrapper: "```\n\n```",
                                emptyOffset: 4,
                                offset: 8,
                                suffix: "\n```",
                            },
                            Link: {
                                wrapper: "[",
                                emptyWrapper: "[]",
                                emptyOffset: 1,
                                offset: 3,
                                suffix: "](url)",
                            },
                            Image: {
                                wrapper: "![",
                                emptyWrapper: "![]",
                                emptyOffset: 2,
                                offset: 4,
                                suffix: "](url)",
                            },
                        };

                        const formatConfig = formatMap[item.label];
                        if (formatConfig) {
                            if (hasSelection) {
                                newText =
                                    text.substring(0, start) +
                                    formatConfig.wrapper +
                                    selectedText +
                                    (formatConfig.suffix ||
                                        formatConfig.wrapper) +
                                    text.substring(end);
                                cursorPos = end + formatConfig.offset;
                            } else {
                                newText =
                                    text.substring(0, start) +
                                    formatConfig.emptyWrapper +
                                    text.substring(end);
                                cursorPos = start + formatConfig.emptyOffset;
                            }
                        } else {
                            newText =
                                text.substring(0, start) +
                                item.format +
                                text.substring(end);
                            cursorPos =
                                start +
                                item.format.length +
                                (item.cursorOffset || 0);
                        }

                        el.textarea.value = newText;
                        el.textarea.setSelectionRange(cursorPos, cursorPos);
                    }

                    utils.updateCharCount();
                    utils.autoResize(el.textarea);
                    el.textarea.focus();
                },
            };

            // Event handlers
            const handlers = {
                textareaInput: (e) => {
                    const cursorPos = el.textarea.selectionStart;
                    const textBeforeCursor = el.textarea.value.substring(
                        0,
                        cursorPos,
                    );
                    const lastChar = textBeforeCursor.charAt(
                        textBeforeCursor.length - 1,
                    );

                    if (
                        lastChar === "/" &&
                        (cursorPos === 1 ||
                            textBeforeCursor.charAt(cursorPos - 2) === "\n" ||
                            textBeforeCursor.charAt(cursorPos - 2) === " ")
                    ) {
                        state.slashPosition = cursorPos - 1;
                        state.slashQuery = "";
                        menu.show();
                    } else if (state.slashMenuActive) {
                        const textAfterSlash = textBeforeCursor.substring(
                            state.slashPosition + 1,
                        );
                        if (
                            cursorPos > state.slashPosition &&
                            !textAfterSlash.includes(" ") &&
                            !textAfterSlash.includes("\n")
                        ) {
                            state.slashQuery = textAfterSlash;
                            state.selectedMenuIndex = 0;
                            menu.show();
                        } else {
                            menu.hide();
                        }
                    }

                    utils.updateCharCount();
                    utils.autoResize(el.textarea);
                },

                textareaKeydown: (e) => {
                    if (state.slashMenuActive) {
                        const allItems =
                            el.slashMenu.querySelectorAll(".menu-item");
                        const contextualItems = utils.getContextualMenuItems();

                        if (allItems.length === 0) {
                            if (e.key === "Escape" || e.key === "Backspace") {
                                e.preventDefault();
                                menu.hide();
                            }
                            return;
                        }

                        switch (e.key) {
                            case "ArrowDown":
                                e.preventDefault();
                                state.selectedMenuIndex =
                                    (state.selectedMenuIndex + 1) %
                                    allItems.length;
                                menu.updateSelection();
                                break;
                            case "ArrowUp":
                                e.preventDefault();
                                state.selectedMenuIndex =
                                    (state.selectedMenuIndex -
                                        1 +
                                        allItems.length) %
                                    allItems.length;
                                menu.updateSelection();
                                break;
                            case "Enter":
                            case "Tab":
                                e.preventDefault();
                                const selectedItem =
                                    allItems[state.selectedMenuIndex];
                                if (selectedItem.dataset.type === "theme") {
                                    menu.selectTheme(
                                        parseInt(selectedItem.dataset.index),
                                    );
                                } else {
                                    format.apply(
                                        contextualItems[
                                            state.selectedMenuIndex
                                        ],
                                    );
                                }
                                break;
                            case "Escape":
                                e.preventDefault();
                                menu.hide();
                                break;
                            case "Backspace":
                                if (
                                    el.textarea.selectionStart <=
                                    state.slashPosition + 1
                                ) {
                                    menu.hide();
                                }
                                break;
                        }
                    } else {
                        const item = menuItems.find((item) => {
                            if (!item.key) return false;
                            return (
                                e.key.toLowerCase() ===
                                    item.key.toLowerCase() &&
                                (e.ctrlKey || e.metaKey) &&
                                (item.shiftKey ? e.shiftKey : !e.shiftKey) &&
                                (item.altKey ? e.altKey : !e.altKey)
                            );
                        });

                        if (item) {
                            e.preventDefault();
                            format.apply(item);
                        }
                    }
                },

                textareaKeyup: (e) => {
                    // Save scroll position when hitting Enter
                    if (e.key === "Enter") {
                        state.lastScrollPosition = el.textarea.scrollTop;

                        // Restore scroll position after a short delay
                        setTimeout(() => {
                            el.textarea.scrollTop = state.lastScrollPosition;
                        }, 10);
                    }
                },

                documentClick: (e) => {
                    if (
                        !el.slashMenu.contains(e.target) &&
                        e.target !== el.textarea
                    ) {
                        menu.hide();
                    }
                },

                formSubmit: (e) => {
                    if (el.textarea.value.length > CHAR_LIMIT) {
                        e.preventDefault();
                        alert(
                            `Content exceeds ${CHAR_LIMIT.toLocaleString()} character limit.`,
                        );
                        return false;
                    }
                },
            };

            // Initialize
            const init = () => {
                const savedTheme = utils.localStorage.get("selectedTheme", 0);
                theme.apply(savedTheme);
                utils.updateCharCount();

                // Set initial textarea height
                el.textarea.style.height =
                    Math.max(100, el.textarea.scrollHeight) + "px";

                // Event listeners
                el.textarea.addEventListener("input", handlers.textareaInput);
                el.textarea.addEventListener(
                    "keydown",
                    handlers.textareaKeydown,
                );
                el.textarea.addEventListener("keyup", handlers.textareaKeyup);
                document.addEventListener("click", handlers.documentClick);
                el.form.addEventListener("submit", handlers.formSubmit);
            };

            init();
        </script>
    </body>
</html>
