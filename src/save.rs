use std::fs;
use std::path::Path;

use crate::Post;

pub fn ensure_content_directory() -> Result<(), String> {
    let content_dir = Path::new("content");
    if !content_dir.exists() {
        fs::create_dir_all(content_dir)
            .map_err(|e| format!("Failed to create content directory: {}", e))?;
    }
    Ok(())
}

pub fn save_post_to_file(post: &Post) -> Result<(), String> {
    ensure_content_directory()?;

    let filename = format!("content/{}.md", post.id);
    let file_path = Path::new(&filename);

    // Create YAML frontmatter content with strict validation
    let mut frontmatter = String::new();
    frontmatter.push_str("---\n");

    // Validate and sanitize all fields before adding to YAML
    let safe_title = validate_yaml_field(&post.title, "title")?;
    frontmatter.push_str(&format!("title: \"{}\"\n", safe_title));

    if !post.author.is_empty() {
        let safe_author = validate_yaml_field(&post.author, "author")?;
        frontmatter.push_str(&format!("author: \"{}\"\n", safe_author));
    }

    if let Some(ref theme) = post.theme {
        let safe_theme = validate_yaml_field(theme, "theme")?;
        frontmatter.push_str(&format!("theme: \"{}\"\n", safe_theme));
    }

    // Date is safe as it's generated by our own formatter
    frontmatter.push_str(&format!(
        "created_at: \"{}\"\n",
        post.created_at.format("%Y-%m-%d")
    ));
    frontmatter.push_str("---\n\n");

    let file_content = format!("{}{}", frontmatter, post.raw_content);

    fs::write(file_path, file_content)
        .map_err(|e| format!("Failed to write post to file {}: {}", filename, e))?;

    Ok(())
}

pub fn post_file_exists(post_id: &str) -> bool {
    let filename = format!("content/{}.md", post_id);
    Path::new(&filename).exists()
}

// Validate YAML field content and prevent injection attacks
fn validate_yaml_field(input: &str, field_name: &str) -> Result<String, String> {
    // Check for dangerous characters that could break YAML structure
    if input.contains('\0')
        || input.contains('\r')
        || input.contains('\n')
        || input.contains('\t')
        || input.contains("---")
        || input.contains("...")
    {
        return Err(format!("Invalid characters in field '{}'", field_name));
    }

    // Check for potential injection patterns
    if input.contains("</")
        || input.contains("<script")
        || input.contains("javascript:")
        || input.contains("data:")
        || input.contains("vbscript:")
    {
        return Err(format!(
            "Potential injection detected in field '{}'",
            field_name
        ));
    }

    // Limit field lengths
    let max_len = match field_name {
        "title" => 200,
        "author" => 100,
        "theme" => 50,
        _ => 100,
    };

    if input.len() > max_len {
        return Err(format!("Field '{}' exceeds maximum length", field_name));
    }

    // Escape YAML-specific characters
    Ok(input
        .replace("\\", "\\\\")
        .replace("\"", "\\\"")
        .replace("#", "\\#")
        .replace(":", "\\:")
        .replace("|", "\\|")
        .replace(">", "\\>"))
}

// Helper function to escape YAML strings (kept for compatibility)
fn escape_yaml_string(s: &str) -> String {
    s.replace("\\", "\\\\")
        .replace("\"", "\\\"")
        .replace("\n", "\\n")
        .replace("\r", "\\r")
        .replace("\t", "\\t")
}

// Parse YAML frontmatter from file content
fn parse_frontmatter(content: &str) -> Option<(std::collections::HashMap<String, String>, String)> {
    if !content.starts_with("---\n") {
        return None;
    }

    let rest = &content[4..]; // Skip "---\n"
    if let Some(end_pos) = rest.find("\n---\n") {
        let yaml_content = &rest[..end_pos];
        let body = &rest[end_pos + 5..]; // Skip "\n---\n"

        let mut metadata = std::collections::HashMap::new();

        for line in yaml_content.lines() {
            if let Some(colon_pos) = line.find(':') {
                let key = line[..colon_pos].trim();
                let value = line[colon_pos + 1..].trim();

                // Remove quotes if present
                let clean_value = if value.starts_with('"') && value.ends_with('"') {
                    &value[1..value.len() - 1]
                } else {
                    value
                };

                metadata.insert(key.to_string(), clean_value.to_string());
            }
        }

        return Some((metadata, body.to_string()));
    }

    None
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;
    use serial_test::serial;
    use std::env;
    use std::path::PathBuf;
    use tempfile::tempdir;

    fn setup_test_env() -> (tempfile::TempDir, PathBuf) {
        let temp_dir = tempdir().unwrap();
        let content_dir = temp_dir.path().join("content");
        std::fs::create_dir_all(&content_dir).unwrap();
        (temp_dir, content_dir)
    }

    #[test]
    fn test_ensure_content_directory() {
        let (_temp_dir, content_dir) = setup_test_env();

        // Test the function directly
        assert!(ensure_content_directory().is_ok());

        // Also test that our setup worked
        assert!(content_dir.exists());
        assert!(content_dir.is_dir());
    }

    #[test]
    #[serial]
    fn test_save_and_load_post() {
        let (temp_dir, _content_dir) = setup_test_env();

        // Change to temp directory for this test
        let old_dir = env::current_dir().unwrap();
        env::set_current_dir(temp_dir.path()).unwrap();

        let post = Post {
            id: "test-post-01-01-2024".to_string(),
            title: "Test Post".to_string(),
            author: "Test Author".to_string(),
            content: "<p>Rendered content</p>".to_string(),
            raw_content: "Raw content here".to_string(),
            created_at: Utc::now(),
            theme: Some("dark".to_string()),
        };

        // Save post
        assert!(save_post_to_file(&post).is_ok());

        // Check file exists
        assert!(post_file_exists("test-post-01-01-2024"));

        // Restore original directory
        env::set_current_dir(old_dir).unwrap();
    }

    #[test]
    #[serial]
    fn test_load_nonexistent_post() {
        let (temp_dir, _content_dir) = setup_test_env();

        // Change to temp directory for this test
        let old_dir = env::current_dir().unwrap();
        env::set_current_dir(temp_dir.path()).unwrap();

        ensure_content_directory().unwrap();

        // Restore original directory
        env::set_current_dir(old_dir).unwrap();
    }

    #[test]
    #[serial]
    fn test_delete_post_file() {
        let (temp_dir, _content_dir) = setup_test_env();

        // Change to temp directory for this test
        let old_dir = env::current_dir().unwrap();
        env::set_current_dir(temp_dir.path()).unwrap();

        ensure_content_directory().unwrap();

        let post = Post {
            id: "delete-test-01-01-2024".to_string(),
            title: "Delete Test".to_string(),
            author: "Test Author".to_string(),
            content: "<p>Content</p>".to_string(),
            raw_content: "Content".to_string(),
            created_at: Utc::now(),
            theme: None,
        };

        // Save and verify exists
        save_post_to_file(&post).unwrap();
        assert!(post_file_exists("delete-test-01-01-2024"));

        // Restore original directory
        env::set_current_dir(old_dir).unwrap();
    }

    #[test]
    #[serial]
    fn test_file_format() {
        let (temp_dir, _content_dir) = setup_test_env();

        // Change to temp directory for this test
        let old_dir = env::current_dir().unwrap();
        env::set_current_dir(temp_dir.path()).unwrap();

        ensure_content_directory().unwrap();

        let post = Post {
            id: "format-test-01-01-2024".to_string(),
            title: "Format Test".to_string(),
            author: "Test Author".to_string(),
            content: "<p>Rendered</p>".to_string(),
            raw_content: "This is the user content\nWith multiple lines".to_string(),
            created_at: Utc::now(),
            theme: Some("dark".to_string()),
        };

        assert!(save_post_to_file(&post).is_ok());

        // Read raw file content to verify YAML frontmatter format
        let raw_file = fs::read_to_string("content/format-test-01-01-2024.md").unwrap();

        // Should start with YAML frontmatter
        assert!(raw_file.starts_with("---\n"));
        assert!(raw_file.contains("title: \"Format Test\""));
        assert!(raw_file.contains("author: \"Test Author\""));
        assert!(raw_file.contains("theme: \"dark\""));
        assert!(raw_file.contains("created_at: \""));
        // Should use date-only format (YYYY-MM-DD), not full timestamp
        // Check that created_at contains a date pattern like "2024-12-29"
        let created_line = raw_file
            .lines()
            .find(|line| line.contains("created_at: "))
            .unwrap();
        assert!(created_line.contains("created_at: \"20")); // Year starts with 20
        assert!(created_line.matches('-').count() == 2); // Two dashes in YYYY-MM-DD
        assert!(raw_file.contains("\n---\n"));

        // Should contain the raw content after frontmatter
        assert!(raw_file.contains("This is the user content\nWith multiple lines"));

        // Restore original directory
        env::set_current_dir(old_dir).unwrap();
    }

    #[test]
    #[serial]
    fn test_file_format_no_author() {
        let (temp_dir, _content_dir) = setup_test_env();

        // Change to temp directory for this test
        let old_dir = env::current_dir().unwrap();
        env::set_current_dir(temp_dir.path()).unwrap();

        let post = Post {
            id: "no-author-test-01-01-2024".to_string(),
            title: "No Author Test".to_string(),
            author: "".to_string(),
            content: "<p>Rendered</p>".to_string(),
            raw_content: "Content without author".to_string(),
            created_at: Utc::now(),
            theme: Some("light".to_string()),
        };

        assert!(save_post_to_file(&post).is_ok());

        // Read raw file content to verify YAML frontmatter format
        let raw_file = fs::read_to_string("content/no-author-test-01-01-2024.md").unwrap();

        // Should start with YAML frontmatter
        assert!(raw_file.starts_with("---\n"));
        assert!(raw_file.contains("title: \"No Author Test\""));
        assert!(!raw_file.contains("author:")); // No author field should be present
        assert!(raw_file.contains("theme: \"light\""));
        assert!(raw_file.contains("created_at: \""));
        // Should use date-only format (YYYY-MM-DD), not full timestamp
        // Check that created_at contains a date pattern like "2024-12-29"
        let created_line = raw_file
            .lines()
            .find(|line| line.contains("created_at: "))
            .unwrap();
        assert!(created_line.contains("created_at: \"20")); // Year starts with 20
        assert!(created_line.matches('-').count() == 2); // Two dashes in YYYY-MM-DD
        assert!(raw_file.contains("\n---\n"));

        // Should contain the raw content after frontmatter
        assert!(raw_file.contains("Content without author"));

        // Restore original directory
        env::set_current_dir(old_dir).unwrap();
    }
}
